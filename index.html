<!DOCTYPE html>
<html lang="it">
<head>
  <meta charset="utf-8" />
  <title>Atlante Illustrato dei Promessi Sposi</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster/dist/MarkerCluster.css" />
  <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster/dist/MarkerCluster.Default.css" />

  <style>
    body, html {
      margin: 0;
      padding: 0;
      height: 100%;
      font-family: 'Segoe UI', sans-serif;
      background-color: #1d2b2f;
      color: #eee;
      overflow: hidden;
    }

    #map {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 1;
    }

    #timeline {
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      height: 0;
      overflow: hidden;
      background: linear-gradient(180deg, #1d2b2f 0%, #243339 100%);
      border-top: 2px solid #333;
      padding: 0;
      z-index: 1000;
      transition: height 0.4s ease, padding 0.4s ease;
      box-shadow: 0 -4px 20px rgba(0,0,0,0.3);
    }

    #timeline.active {
      height: 280px;
      padding: 20px;
      overflow-y: auto;
      overflow-x: hidden;
    }

    /* Timeline grid layout */
    .timeline-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
      gap: 20px;
      max-height: 240px;
      overflow-y: auto;
      overflow-x: hidden;
      padding-right: 10px;
    }

    .chapter-group {
      background: rgba(255, 255, 255, 0.05);
      border-radius: 12px;
      padding: 12px;
      transition: all 0.3s ease;
      border: 1px solid transparent;
    }

    .chapter-group:hover {
      background: rgba(255, 255, 255, 0.08);
      border-color: rgba(255, 165, 0, 0.3);
    }

    .chapter-group.hidden {
      display: none;
    }

    .chapter-label {
      font-weight: bold;
      color: #a0d4f3;
      font-size: 0.75em;
      text-align: center;
      margin-bottom: 8px;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      transition: color 0.3s ease;
    }

    .chapter-group-points {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      justify-content: center;
      align-items: center;
      min-height: 40px;
    }

    .timeline-point {
      width: 16px;
      height: 16px;
      border-radius: 50%;
      background-color: #eee;
      cursor: pointer;
      transition: all 0.3s ease;
      position: relative;
      border: 2px solid transparent;
      box-shadow: 0 2px 4px rgba(0,0,0,0.2);
    }

    .timeline-point:hover {
      transform: scale(1.4);
      border-color: rgba(255, 255, 255, 0.6);
      box-shadow: 0 4px 12px rgba(255, 255, 255, 0.3);
      z-index: 10;
    }

    .timeline-point.active {
      transform: scale(1.3);
      border-color: #ffd700;
      box-shadow: 0 0 20px rgba(255, 215, 0, 0.6);
    }

    .timeline-point.hidden {
      display: none;
    }

    .timeline-point.highlighted {
      animation: pulseGlow 1.5s infinite;
      border-color: #ffa500;
      transform: scale(1.2);
      z-index: 5;
    }

    @keyframes pulseGlow {
      0%, 100% {
        box-shadow: 0 0 15px rgba(255, 165, 0, 0.8);
      }
      50% {
        box-shadow: 0 0 25px rgba(255, 165, 0, 0.4);
      }
    }

    @keyframes bounceIn {
      0% { transform: scale(0); }
      50% { transform: scale(1.2); }
      100% { transform: scale(1); }
    }

    .chapter-label.active {
      color: #ffd700;
    }

    /* Place indicator */
    .place-indicator {
      position: fixed;
      top: 50%;
      right: 30px;
      background: linear-gradient(135deg, #ffa500, #ff8c00);
      color: #1d2b2f;
      padding: 12px 20px;
      border-radius: 25px;
      font-weight: bold;
      font-size: 16px;
      white-space: nowrap;
      box-shadow: 0 4px 16px rgba(255, 165, 0, 0.4);
      transform: translateY(-50%) translateX(200%);
      transition: transform 0.4s ease;
      z-index: 1050;
      backdrop-filter: blur(10px);
    }

    .place-indicator.visible {
      transform: translateY(-50%) translateX(0);
    }

    .place-indicator::before {
      content: '';
      position: absolute;
      left: -8px;
      top: 50%;
      width: 0;
      height: 0;
      border-top: 8px solid transparent;
      border-bottom: 8px solid transparent;
      border-right: 8px solid #ffa500;
      transform: translateY(-50%);
    }

    /* Enhanced FAB Menu */
    .fab-container {
      position: fixed;
      bottom: 20px;
      left: 20px;
      z-index: 1100;
      transition: bottom 0.4s ease;
    }

    .fab-main {
      display: flex;
      flex-direction: column;
      align-items: flex-start;
      gap: 15px;
    }

    .fab-sphere {
      width: 48px;
      height: 48px;
      border-radius: 50%;
      border: none;
      cursor: pointer;
      box-shadow: 0 4px 12px rgba(0,0,0,0.3);
      transition: all 0.3s ease;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 20px;
      font-weight: bold;
      position: relative;
    }

    #fab-toggle {
      background: linear-gradient(135deg, #ffa500, #ff8c00);
      color: #1d2b2f;
    }

    #fab-timeline {
      background: linear-gradient(135deg, #4d88ff, #3366ff);
      color: white;
    }

    #fab-filters {
      background: linear-gradient(135deg, #66a3ff, #4d88ff);
      color: white;
    }

    .fab-sphere:hover {
      transform: scale(1.1);
      box-shadow: 0 6px 16px rgba(0,0,0,0.4);
    }

    .fab-sphere.active {
      background: linear-gradient(135deg, #ffd700, #ffcc00);
      color: #1d2b2f;
    }

    /* Side panels */
    .fab-panel {
      position: absolute;
      left: 60px;
      bottom: 0;
      background: rgba(43, 59, 69, 0.95);
      backdrop-filter: blur(10px);
      padding: 15px;
      border-radius: 12px;
      box-shadow: 0 8px 24px rgba(0,0,0,0.3);
      display: none;
      flex-direction: column;
      gap: 10px;
      min-width: 150px;
      animation: slideIn 0.3s ease;
    }

    .fab-panel.visible {
      display: flex;
    }

    @keyframes slideIn {
      from {
        opacity: 0;
        transform: translateX(-20px);
      }
      to {
        opacity: 1;
        transform: translateX(0);
      }
    }

    .fab-panel-btn {
      background: linear-gradient(135deg, #ffa500, #ff8c00);
      color: #1d2b2f;
      border: none;
      border-radius: 8px;
      padding: 10px 15px;
      font-weight: bold;
      cursor: pointer;
      transition: all 0.3s ease;
      white-space: nowrap;
    }

    .fab-panel-btn:hover {
      background: linear-gradient(135deg, #ffb933, #ffa500);
      transform: translateY(-2px);
    }

    .fab-panel-btn.active {
      background: linear-gradient(135deg, #ffd700, #ffcc00);
      box-shadow: 0 0 10px rgba(255, 215, 0, 0.5);
    }

    .fab-dropdown {
      background: #eee;
      color: #1d2b2f;
      border-radius: 6px;
      border: none;
      padding: 8px 12px;
      font-size: 14px;
      cursor: pointer;
      transition: all 0.3s ease;
    }

    .fab-dropdown:hover {
      background: #f5f5f5;
      box-shadow: 0 2px 8px rgba(0,0,0,0.2);
    }

    /* Timeline stats */
    .timeline-stats {
      position: absolute;
      top: 10px;
      right: 20px;
      background: rgba(0,0,0,0.6);
      padding: 8px 12px;
      border-radius: 20px;
      font-size: 12px;
      color: #a0d4f3;
      backdrop-filter: blur(5px);
    }

    .leaflet-control-zoom {
      bottom: 30px !important;
      right: 20px !important;
      transition: bottom 0.4s ease !important;
      z-index: 1001 !important;
    }

    /* City area styles */
    .city-area {
      fill-opacity: 0.7;
      stroke-width: 2;
      stroke-opacity: 0.9;
      cursor: pointer;
      transition: all 0.3s ease;
    }

    .city-area:hover {
      fill-opacity: 0.9;
      stroke-width: 3;
    }

    .city-label {
      font-family: 'Segoe UI', sans-serif;
      font-weight: bold;
      font-size: 12px;
      fill: #1d2b2f;
      text-anchor: middle;
      dominant-baseline: central;
      pointer-events: none;
      text-shadow: 1px 1px 2px rgba(255,255,255,0.8);
    }

    .city-count {
      font-family: 'Segoe UI', sans-serif;
      font-weight: bold;
      font-size: 10px;
      fill: #1d2b2f;
      text-anchor: middle;
      dominant-baseline: central;
      pointer-events: none;
      text-shadow: 1px 1px 2px rgba(255,255,255,0.8);
    }

    /* Item card popup */
    .item-card {
      position: absolute;
      background: rgba(0, 0, 0, 0.95);
      color: #eee;
      border: 2px solid #66a3ff;
      border-radius: 12px;
      padding: 15px;
      max-width: 300px;
      box-shadow: 0 8px 24px rgba(0,0,0,0.5);
      z-index: 500;
      font-size: 14px;
      line-height: 1.4;
      backdrop-filter: blur(10px);
    }

    .item-card img {
      width: 100%;
      border-radius: 8px;
      margin: 10px 0;
    }

    .item-card h3 {
      margin: 0 0 10px 0;
      color: #66a3ff;
      font-size: 16px;
      padding-right: 35px;
    }

    .item-card .meta {
      margin: 5px 0;
      color: #a0d4f3;
    }

    .item-card .link {
      display: inline-block;
      margin-top: 10px;
      padding: 8px 15px;
      background: linear-gradient(135deg, #66a3ff, #4d88ff);
      color: white;
      text-decoration: none;
      border-radius: 6px;
      font-weight: bold;
      transition: all 0.3s ease;
    }

    .item-card .link:hover {
      background: linear-gradient(135deg, #80bfff, #66a3ff);
      transform: translateY(-2px);
    }

    .card-close {
      position: absolute;
      top: 10px;
      right: 15px;
      width: 25px;
      height: 25px;
      background: rgba(255, 0, 0, 0.7);
      color: white;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      font-size: 16px;
      font-weight: bold;
      transition: all 0.3s ease;
    }

    .card-close:hover {
      background: rgba(255, 0, 0, 0.9);
      transform: scale(1.1);
    }

    .connection-line {
      opacity: 0.7;
      transition: all 0.3s ease;
    }

    /* Quick tooltip */
    .quick-tooltip {
      pointer-events: none;
      font-family: 'Segoe UI', sans-serif;
      box-shadow: 0 4px 12px rgba(0,0,0,0.3);
    }

    /* Spider graph elements */
    .spider-node {
      cursor: pointer;
      transition: all 0.3s ease;
    }

    .spider-node-center {
      stroke: #ffa500;
      stroke-width: 3px;
    }

    .spider-node-item {
      stroke: #fff;
      stroke-width: 2px;
    }

    .spider-node:hover {
      stroke-width: 4px;
    }

    .spider-link {
      stroke: #66a3ff;
      stroke-opacity: 0.6;
      stroke-width: 2px;
    }

    .spider-label {
      font-family: 'Segoe UI', sans-serif;
      font-size: 10px;
      fill: #eee;
      text-anchor: middle;
      dominant-baseline: central;
      pointer-events: none;
      text-shadow: 1px 1px 2px rgba(0,0,0,0.8);
    }

    /* Error message */
    .error-message {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(255, 0, 0, 0.9);
      color: white;
      padding: 20px;
      border-radius: 10px;
      text-align: center;
      z-index: 2000;
      max-width: 400px;
    }

    /* Scrollbar styling */
    .timeline-grid::-webkit-scrollbar {
      width: 8px;
    }

    .timeline-grid::-webkit-scrollbar-track {
      background: rgba(255,255,255,0.1);
      border-radius: 4px;
    }

    .timeline-grid::-webkit-scrollbar-thumb {
      background: rgba(255,165,0,0.6);
      border-radius: 4px;
    }

    .timeline-grid::-webkit-scrollbar-thumb:hover {
      background: rgba(255,165,0,0.8);
    }
  </style>
</head>

<body>
  <div id="map"></div>
  <div id="timeline">
    <div class="timeline-stats" id="timeline-stats"></div>
    <div class="timeline-grid" id="timeline-grid"></div>
  </div>
  
  <!-- Enhanced FAB Menu -->
  <div id="fab-container" class="fab-container">
    <div class="fab-main">
      <!-- Toggle principale -->
      <button id="fab-toggle" class="fab-sphere" title="Menu">
        &#9776;
      </button>

      <!-- Timeline controls -->
      <div style="position: relative;">
        <button id="fab-timeline" class="fab-sphere" title="Timeline" style="display: none;">
          &#9636;
        </button>
        <div id="timeline-panel" class="fab-panel">
          <button class="fab-panel-btn" id="btnPromessi">Promessi Sposi</button>
          <button class="fab-panel-btn" id="btnColonna">Colonna Infame</button>
        </div>
      </div>

      <!-- Filter controls -->
      <div style="position: relative;">
        <button id="fab-filters" class="fab-sphere" title="Filtri" style="display: none;">
          &#9681;
        </button>
        <div id="filters-panel" class="fab-panel">
          <select id="dropdown-chapter" class="fab-dropdown">
            <option value="">Tutti i Capitoli</option>
          </select>
          <select id="dropdown-place" class="fab-dropdown">
            <option value="">Tutti i Luoghi</option>
          </select>
          <select id="dropdown-author" class="fab-dropdown">
            <option value="">Tutti gli Autori</option>
          </select>
        </div>
      </div>
    </div>
  </div>

  <div id="place-indicator" class="place-indicator"></div>

  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <script>
    // Inizializzazione mappa
    const map = L.map('map', {
      zoomControl: false
    }).setView([45.5, 9.3], 8);

    // Controllo zoom
    const zoomControl = L.control.zoom({
      position: 'bottomright'
    }).addTo(map);

    // Tile layer
    L.tileLayer('https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png', {
      attribution: '&copy; OpenStreetMap contributors &copy; CARTO',
      subdomains: 'abcd',
      maxZoom: 19
    }).addTo(map);

    // SVG overlay per le aree città
    const svg = d3.select(map.getPanes().overlayPane).append("svg")
      .style("overflow", "visible");
    const g = svg.append("g").attr("class", "leaflet-zoom-hide");

    // Variabili globali
    const featureMap = new Map();
    const chapterMap = new Map();
    const chapterGroupMap = new Map();
    const pointMap = new Map();
    const placePointsMap = new Map();
    const cityData = new Map(); // place -> {coords, items, visibleCount}
    
    const timeline = document.getElementById('timeline');
    const timelineGrid = document.getElementById('timeline-grid');
    const timelineStats = document.getElementById('timeline-stats');
    const placeIndicator = document.getElementById('place-indicator');
    const fabContainer = document.getElementById('fab-container');
    
    // FAB elements
    const fabToggle = document.getElementById('fab-toggle');
    const fabTimeline = document.getElementById('fab-timeline');
    const fabFilters = document.getElementById('fab-filters');
    const timelinePanel = document.getElementById('timeline-panel');
    const filtersPanel = document.getElementById('filters-panel');
    const btnPromessi = document.getElementById('btnPromessi');
    const btnColonna = document.getElementById('btnColonna');
    
    // Dropdown elements
    const dropdownChapter = document.getElementById('dropdown-chapter');
    const dropdownPlace = document.getElementById('dropdown-place');
    const dropdownAuthor = document.getElementById('dropdown-author');

    let currentTimeline = null;
    let sortedFeatures = [];
    let fabOpen = false;
    let currentHoveredPlace = null;
    let currentSpiderGraph = null;
    let currentItemCard = null;
    let activeSpiderPlace = null; // Traccia quale città ha il grafo attivo

    // Palette colori per luoghi (ritorna ai blu originali)
    const colorPalette = [
      '#b3ecff', '#99d6ff', '#80bfff', '#66a3ff', '#4d88ff',
      '#3366ff', '#1a53ff', '#0040ff', '#0033cc', '#001a80'
    ];

    const placeColorMap = new Map();
    let placeIndex = 0;

    function getColorForPlace(place) {
      if (!placeColorMap.has(place)) {
        placeColorMap.set(place, colorPalette[placeIndex % colorPalette.length]);
        placeIndex++;
      }
      return placeColorMap.get(place);
    }

    // Gestione posizione controlli
    function updateControlPositions() {
      const isActive = timeline.classList.contains('active');
      const newBottom = isActive ? '320px' : '30px';
      
      const zoomEl = document.querySelector('.leaflet-control-zoom');
      if (zoomEl) {
        zoomEl.style.bottom = newBottom;
      }
      
      fabContainer.style.bottom = isActive ? '300px' : '20px';
    }

    // Place highlighting system
    function highlightPlacePoints(place, hoveredPoint) {
      clearHighlights();
      
      if (!place) return;
      
      currentHoveredPlace = place;
      const points = placePointsMap.get(place) || [];
      const visiblePoints = points.filter(p => p.style.display !== 'none' && !p.classList.contains('hidden'));
      
      if (visiblePoints.length < 2) return;
      
      visiblePoints.forEach(point => {
        point.classList.add('highlighted');
      });
      
      placeIndicator.textContent = `${place} (${visiblePoints.length} punti)`;
      placeIndicator.classList.add('visible');
    }

    function clearHighlights() {
      document.querySelectorAll('.timeline-point.highlighted').forEach(point => {
        point.classList.remove('highlighted', 'show-connections');
      });
      
      placeIndicator.classList.remove('visible');
      currentHoveredPlace = null;
    }

    // FAB Menu Management
    function toggleFAB() {
      fabOpen = !fabOpen;
      
      if (fabOpen) {
        fabToggle.classList.add('active');
        fabTimeline.style.display = 'flex';
        fabFilters.style.display = 'flex';
        fabToggle.innerHTML = '&#10005;';
      } else {
        fabToggle.classList.remove('active');
        fabTimeline.style.display = 'none';
        fabFilters.style.display = 'none';
        fabToggle.innerHTML = '&#9776;';
        
        timelinePanel.classList.remove('visible');
        filtersPanel.classList.remove('visible');
        fabTimeline.classList.remove('active');
        fabFilters.classList.remove('active');
        
        // Chiudi automaticamente la timeline quando si chiude il FAB
        if (timeline.classList.contains('active')) {
          timeline.classList.remove('active');
          currentTimeline = null;
          chapterGroupMap.clear();
          clearHighlights();
          timelineStats.textContent = '';
          timelineGrid.innerHTML = '';
          
          // Reset button states
          btnPromessi.classList.remove('active');
          btnColonna.classList.remove('active');
          
          updateControlPositions();
          map.invalidateSize();
        }
      }
    }

    function showTimelinePanel() {
      if (!fabOpen) return;
      
      const isVisible = timelinePanel.classList.contains('visible');
      
      filtersPanel.classList.remove('visible');
      fabFilters.classList.remove('active');
      
      if (isVisible) {
        timelinePanel.classList.remove('visible');
        fabTimeline.classList.remove('active');
      } else {
        timelinePanel.classList.add('visible');
        fabTimeline.classList.add('active');
      }
    }

    function showFiltersPanel() {
      if (!fabOpen) return;
      
      const isVisible = filtersPanel.classList.contains('visible');
      
      timelinePanel.classList.remove('visible');
      fabTimeline.classList.remove('active');
      
      if (isVisible) {
        filtersPanel.classList.remove('visible');
        fabFilters.classList.remove('active');
      } else {
        filtersPanel.classList.add('visible');
        fabFilters.classList.add('active');
      }
    }

    // Timeline stats
    function updateTimelineStats() {
      let visiblePoints = 0;
      let totalChapters = 0;
      
      for (const [chapter, group] of chapterGroupMap.entries()) {
        if (group.style.display !== 'none' && !group.classList.contains('hidden')) {
          totalChapters++;
          const points = group.querySelectorAll('.timeline-point:not(.hidden)');
          visiblePoints += points.length;
        }
      }
      
      timelineStats.textContent = `${visiblePoints} punti • ${totalChapters} capitoli`;
    }

    // Coordinate transformation
    function latLngToLayerPoint(latlng) {
      return map.latLngToLayerPoint(L.latLng(latlng));
    }

    function layerPointToLatLng(point) {
      return map.layerPointToLatLng(L.point(point.x, point.y));
    }

    // Creazione aree città
    function createCityAreas() {
      g.selectAll("*").remove();
      
      if (cityData.size === 0) return;
      
      const maxItems = Math.max(...Array.from(cityData.values()).map(city => city.visibleCount));
      const minRadius = 15;
      const maxRadius = 80;
      
      for (const [place, data] of cityData.entries()) {
        if (data.visibleCount === 0) continue;
        
        const center = latLngToLayerPoint(data.coords);
        const proportion = data.visibleCount / maxItems;
        const radius = minRadius + (maxRadius - minRadius) * Math.sqrt(proportion);
        const color = getColorForPlace(place);
        
        // Area circolare
        const circle = g.append("circle")
          .attr("class", "city-area")
          .attr("cx", center.x)
          .attr("cy", center.y)
          .attr("r", radius)
          .attr("fill", color)
          .attr("stroke", d3.rgb(color).darker(0.5))
          .attr("data-place", place)
          .style("cursor", "pointer")
          .on("click", () => showSpiderGraph(place, data));
        
        // Etichetta città
        g.append("text")
          .attr("class", "city-label")
          .attr("x", center.x)
          .attr("y", center.y - 5)
          .text(place);
        
        // Conteggio
        g.append("text")
          .attr("class", "city-count")
          .attr("x", center.x)
          .attr("y", center.y + 8)
          .text(`(${data.visibleCount})`);
      }
    }

    // Spider graph integrato sulla mappa
    function showSpiderGraph(placeName, placeData) {
      // Chiudi spider graph esistente
      closeSpiderGraph();
      
      const visibleItems = placeData.items.filter(item => {
        const point = pointMap.get(item.sequence);
        return point && !point.classList.contains('hidden') && point.style.display !== 'none';
      });
      
      if (visibleItems.length === 0) return;
      
      activeSpiderPlace = placeName;
      createIntegratedSpiderGraph(placeName, placeData, visibleItems);
    }

    // Spider graph migliorato - Layout a griglia organizzata
    function createIntegratedSpiderGraph(placeName, placeData, visibleItems) {
      const center = latLngToLayerPoint(placeData.coords);
      
      // Rimuovi eventuali spider graph esistenti
      g.selectAll(".spider-element").remove();
      
      // Layout intelligente basato sul numero di item
      const itemCount = visibleItems.length;
      let layout;
      
      if (itemCount <= 6) {
        // Layout circolare per pochi item
        layout = createCircularLayout(center, visibleItems, 100);
      } else if (itemCount <= 12) {
        // Layout a doppio anello
        layout = createDoubleRingLayout(center, visibleItems, 80, 140);
      } else {
        // Layout a griglia organizzata per molti item
        layout = createGridLayout(center, visibleItems, 60);
      }
      
      // Crea i nodi
      const centerNode = {
        id: 'center',
        x: center.x,
        y: center.y,
        type: 'center',
        label: `${placeName} (${itemCount})`
      };
      
      const nodes = [centerNode, ...layout];
      
      // Crea i link
      const links = visibleItems.map(item => ({ 
        source: 'center', 
        target: item.sequence 
      }));
      
      // Aggiungi i link con gradiente
      const link = g.selectAll(".spider-link")
        .data(links)
        .enter().append("line")
        .attr("class", "spider-link spider-element")
        .attr("stroke", "#66a3ff")
        .attr("stroke-width", 1.5)
        .attr("stroke-opacity", 0.4)
        .attr("stroke-dasharray", "2,2");
      
      // Aggiungi area di background per il cluster
      const clusterRadius = Math.max(120, Math.sqrt(itemCount) * 30);
      g.append("circle")
        .attr("class", "spider-background spider-element")
        .attr("cx", center.x)
        .attr("cy", center.y)
        .attr("r", clusterRadius)
        .attr("fill", "rgba(102, 163, 255, 0.1)")
        .attr("stroke", "rgba(102, 163, 255, 0.3)")
        .attr("stroke-width", 2)
        .attr("stroke-dasharray", "5,5");
      
      // Aggiungi i nodi item con dimensioni proporzionate
      const itemNodes = g.selectAll(".spider-node-item")
        .data(layout)
        .enter().append("circle")
        .attr("class", "spider-node spider-element spider-node-item")
        .attr("cx", d => d.x)
        .attr("cy", d => d.y)
        .attr("r", 6)
        .attr("fill", d => {
          const point = pointMap.get(d.id);
          return point ? point.style.backgroundColor : "#66a3ff";
        })
        .attr("stroke", "#fff")
        .attr("stroke-width", 2)
        .style("cursor", "pointer");
      
      // Nodo centrale più grande
      const centerNodeEl = g.append("circle")
        .attr("class", "spider-node spider-element spider-node-center")
        .attr("cx", center.x)
        .attr("cy", center.y)
        .attr("r", 12)
        .attr("fill", "#ffa500")
        .attr("stroke", "#ff8c00")
        .attr("stroke-width", 3)
        .style("cursor", "pointer");
      
      // Etichetta centrale
      const centerLabel = g.append("text")
        .attr("class", "spider-center-label spider-element")
        .attr("x", center.x)
        .attr("y", center.y + 20)
        .attr("font-size", "11px")
        .attr("font-weight", "bold")
        .attr("fill", "#ffa500")
        .attr("text-anchor", "middle")
        .attr("dominant-baseline", "central")
        .text(centerNode.label);
      
      // Posiziona i link
      link
        .attr("x1", center.x)
        .attr("y1", center.y)
        .attr("x2", d => {
          const target = layout.find(n => n.id === d.target);
          return target ? target.x : center.x;
        })
        .attr("y2", d => {
          const target = layout.find(n => n.id === d.target);
          return target ? target.y : center.y;
        });
      
      // Aggiungi interazioni migliorate
      itemNodes
        .on("click", (event, d) => {
          const mapPoint = layerPointToLatLng({x: d.x, y: d.y});
          showItemCardLinked(d.data, mapPoint);
          
          // Highlight timeline point
          const point = pointMap.get(d.id);
          if (point) {
            point.classList.add('active');
            setTimeout(() => point.classList.remove('active'), 2000);
          }
        })
        .on("mouseover", (event, d) => {
          // Ingrandisci e mostra tooltip
          d3.select(event.currentTarget)
            .transition()
            .duration(200)
            .attr("r", 8)
            .attr("stroke-width", 3);
          
          // Mostra titolo dell'item
          showQuickTooltip(event, d.data.title);
        })
        .on("mouseout", (event, d) => {
          d3.select(event.currentTarget)
            .transition()
            .duration(200)
            .attr("r", 6)
            .attr("stroke-width", 2);
          
          hideQuickTooltip();
        });
      
      // Click sul nodo centrale per chiudere
      centerNodeEl.on("click", () => {
        closeSpiderGraph();
      });
      
      // Animazioni di entrata scaglionate
      itemNodes
        .style("opacity", 0)
        .attr("r", 0)
        .transition()
        .delay((d, i) => i * 50)
        .duration(300)
        .style("opacity", 1)
        .attr("r", 6);
      
      link
        .style("opacity", 0)
        .transition()
        .delay(200)
        .duration(400)
        .style("opacity", 0.4);
      
      centerNodeEl
        .style("opacity", 0)
        .attr("r", 0)
        .transition()
        .duration(400)
        .style("opacity", 1)
        .attr("r", 12);
      
      currentSpiderGraph = { placeName, nodes, links };
    }

    // Layout algorithms
    function createCircularLayout(center, items, radius) {
      return items.map((item, i) => {
        const angle = (2 * Math.PI * i) / items.length;
        return {
          id: item.sequence,
          x: center.x + radius * Math.cos(angle),
          y: center.y + radius * Math.sin(angle),
          data: item
        };
      });
    }

    function createDoubleRingLayout(center, items, innerRadius, outerRadius) {
      const half = Math.ceil(items.length / 2);
      return items.map((item, i) => {
        const isInner = i < half;
        const radius = isInner ? innerRadius : outerRadius;
        const count = isInner ? half : items.length - half;
        const index = isInner ? i : i - half;
        const angle = (2 * Math.PI * index) / count;
        
        return {
          id: item.sequence,
          x: center.x + radius * Math.cos(angle),
          y: center.y + radius * Math.sin(angle),
          data: item
        };
      });
    }

    function createGridLayout(center, items, spacing) {
      const cols = Math.ceil(Math.sqrt(items.length));
      const rows = Math.ceil(items.length / cols);
      const startX = center.x - (cols - 1) * spacing / 2;
      const startY = center.y - (rows - 1) * spacing / 2;
      
      return items.map((item, i) => {
        const col = i % cols;
        const row = Math.floor(i / cols);
        
        return {
          id: item.sequence,
          x: startX + col * spacing,
          y: startY + row * spacing,
          data: item
        };
      });
    }

    // Quick tooltip
    let quickTooltip = null;

    function showQuickTooltip(event, text) {
      hideQuickTooltip();
      
      quickTooltip = document.createElement('div');
      quickTooltip.className = 'quick-tooltip';
      quickTooltip.textContent = text;
      quickTooltip.style.position = 'fixed';
      quickTooltip.style.background = 'rgba(0,0,0,0.8)';
      quickTooltip.style.color = 'white';
      quickTooltip.style.padding = '5px 10px';
      quickTooltip.style.borderRadius = '4px';
      quickTooltip.style.fontSize = '12px';
      quickTooltip.style.zIndex = '3000';
      quickTooltip.style.pointerEvents = 'none';
      quickTooltip.style.maxWidth = '200px';
      quickTooltip.style.left = event.pageX + 10 + 'px';
      quickTooltip.style.top = event.pageY - 30 + 'px';
      
      document.body.appendChild(quickTooltip);
    }

    function hideQuickTooltip() {
      if (quickTooltip) {
        quickTooltip.remove();
        quickTooltip = null;
      }
    }

    // Funzione showItemCardDirect mancante - aggiunta
    function showItemCardDirect(item) {
      closeItemCard();
      
      // Chiudi automaticamente la timeline per rendere visibile la card
      if (timeline.classList.contains('active')) {
        timeline.classList.remove('active');
        updateControlPositions();
        map.invalidateSize();
      }
      
      console.log('Showing direct card for item:', item);
      
      const card = document.createElement('div');
      card.className = 'item-card';
      card.innerHTML = `
        <h3>${item.title || 'Titolo non disponibile'}</h3>
        ${item.image ? `<img src="${item.image}" alt="${item.title}" />` : ''}
        <div class="meta"><strong>Luogo:</strong> ${item.place || 'Non specificato'}</div>
        <div class="meta"><strong>Capitolo:</strong> ${item.chapter || 'Non specificato'}</div>
        <div class="meta"><strong>Pagina:</strong> ${item.page || 'Non specificata'}</div>
        <div class="meta"><strong>Autori:</strong> ${(item.authors && item.authors.length > 0) ? item.authors.join(', ') : 'Non specificati'}</div>
        <a href="${item.link || '#'}" target="_blank" class="link">Vai alla scheda</a>
        <div class="card-close" onclick="closeItemCard()">×</div>
      `;
      
      // Posiziona la card in modo più centrato e meno estremo
      const mapContainer = map.getContainer();
      const mapRect = mapContainer.getBoundingClientRect();
      
      card.style.position = 'fixed';
      card.style.right = Math.min(50, (window.innerWidth - mapRect.width) / 2 + 50) + 'px';
      card.style.top = Math.max(80, mapRect.top + 80) + 'px';
      card.style.maxWidth = '320px';
      
      // Bordo colorato basato sul luogo
      if (item.place) {
        card.style.borderLeft = '4px solid ' + getColorForPlace(item.place);
      }
      
      document.body.appendChild(card);
      currentItemCard = card;
      
      console.log('Direct card created and added to DOM');
      
      // Close on click outside
      setTimeout(() => {
        document.addEventListener('click', closeItemCardOnClickOutside);
      }, 100);
    }

    function showItemCardLinked(item, mapCenter) {
      closeItemCard();
      
      // Chiudi automaticamente la timeline per rendere visibile la card
      if (timeline.classList.contains('active')) {
        timeline.classList.remove('active');
        updateControlPositions();
        map.invalidateSize();
      }
      
      console.log('Showing card for item:', item);
      
      const card = document.createElement('div');
      card.className = 'item-card';
      card.innerHTML = `
        <h3>${item.title || 'Titolo non disponibile'}</h3>
        ${item.image ? `<img src="${item.image}" alt="${item.title}" />` : ''}
        <div class="meta"><strong>Luogo:</strong> ${item.place || 'Non specificato'}</div>
        <div class="meta"><strong>Capitolo:</strong> ${item.chapter || 'Non specificato'}</div>
        <div class="meta"><strong>Pagina:</strong> ${item.page || 'Non specificata'}</div>
        <div class="meta"><strong>Autori:</strong> ${(item.authors && item.authors.length > 0) ? item.authors.join(', ') : 'Non specificati'}</div>
        <a href="${item.link || '#'}" target="_blank" class="link">Vai alla scheda</a>
        <div class="card-close" onclick="closeItemCard()">×</div>
      `;
      
      // Posiziona la card in modo più equilibrato rispetto alla mappa
      const mapContainer = map.getContainer();
      const mapRect = mapContainer.getBoundingClientRect();
      
      // Calcola posizione più centrata evitando gli estremi
      const cardWidth = 320;
      const padding = 80;
      const availableWidth = window.innerWidth - cardWidth - padding * 2;
      const leftPosition = Math.max(padding, Math.min(availableWidth, mapRect.right - cardWidth - padding));
      
      card.style.position = 'fixed';
      card.style.left = leftPosition + 'px';
      card.style.top = Math.max(80, mapRect.top + 80) + 'px';
      card.style.maxWidth = cardWidth + 'px';
      
      // Memorizza il centro per aggiornamenti futuri
      card.linkedCenter = mapCenter;
      
      // Aggiungi indicatore visivo di connessione
      if (item.place) {
        card.style.borderLeft = '4px solid ' + getColorForPlace(item.place);
      }
      
      document.body.appendChild(card);
      currentItemCard = card;
      
      console.log('Card created and added to DOM');
      
      // Crea linea di connessione visiva
      if (mapCenter) {
        createConnectionLine(mapCenter, card);
      }
      
      // Close on click outside
      setTimeout(() => {
        document.addEventListener('click', closeItemCardOnClickOutside);
      }, 100);
    }

    function createConnectionLine(mapCenter, card) {
      // Rimuovi linee esistenti
      removeConnectionLine();
      
      const mapPoint = map.latLngToContainerPoint(mapCenter);
      const mapContainer = map.getContainer();
      const mapRect = mapContainer.getBoundingClientRect();
      
      const line = document.createElement('div');
      line.className = 'connection-line';
      line.style.position = 'fixed';
      line.style.left = (mapRect.left + mapPoint.x) + 'px';
      line.style.top = (mapRect.top + mapPoint.y) + 'px';
      line.style.width = '300px';
      line.style.height = '2px';
      line.style.background = 'linear-gradient(90deg, #66a3ff, transparent)';
      line.style.zIndex = '400';
      line.style.pointerEvents = 'none';
      line.style.transformOrigin = '0 0';
      
      document.body.appendChild(line);
      currentItemCard.connectionLine = line;
    }

    function removeConnectionLine() {
      const existingLine = document.querySelector('.connection-line');
      if (existingLine) {
        existingLine.remove();
      }
    }

    function closeItemCard() {
      if (currentItemCard) {
        document.removeEventListener('click', closeItemCardOnClickOutside);
        removeConnectionLine();
        currentItemCard.remove();
        currentItemCard = null;
      }
    }

    function closeItemCardOnClickOutside(event) {
      if (currentItemCard && !currentItemCard.contains(event.target)) {
        closeItemCard();
      }
    }

    function closeSpiderGraph() {
      if (currentSpiderGraph) {
        // Animazione di uscita
        g.selectAll(".spider-element")
          .transition()
          .duration(300)
          .style("opacity", 0)
          .remove();
        
        currentSpiderGraph = null;
        activeSpiderPlace = null;
      }
      closeItemCard();
    }

    // Update city data with current filters
    function updateCityData() {
      // Reset visible counts
      for (const [place, data] of cityData.entries()) {
        data.visibleCount = 0;
      }
      
      // Count visible items per place
      const placeCounts = new Map();
      for (const [seq, point] of pointMap.entries()) {
        if (!point.classList.contains('hidden') && point.style.display !== 'none') {
          const place = point.dataset.place;
          placeCounts.set(place, (placeCounts.get(place) || 0) + 1);
        }
      }
      
      // Update visible counts in cityData
      for (const [place, count] of placeCounts.entries()) {
        if (cityData.has(place)) {
          cityData.get(place).visibleCount = count;
        }
      }
    }

    // Funzione per applicare i filtri
    function applyFilters() {
      const selectedChapter = dropdownChapter.value;
      const selectedPlace = dropdownPlace.value;
      const selectedAuthor = dropdownAuthor.value;

      // Chiudi spider graph se aperto quando si cambiano i filtri
      closeSpiderGraph();

      const visibleChapters = new Map();

      for (const [seq, feature] of featureMap.entries()) {
        const props = feature.properties;
        const chapter = props.chapter || "Capitolo sconosciuto";
        
        // NORMALIZZA IL NOME DEL LUOGO anche nei filtri
        const place = (props.place || "Luogo sconosciuto").trim().replace(/\s+/g, ' ');
        
        const matchChapter = !selectedChapter || chapter === selectedChapter;
        const matchPlace = !selectedPlace || place === selectedPlace;
        const matchAuthor = !selectedAuthor || (props.authors && props.authors.includes(selectedAuthor));

        const visible = matchChapter && matchPlace && matchAuthor;
        
        if (visible) {
          visibleChapters.set(chapter, (visibleChapters.get(chapter) || 0) + 1);
        }

        // Update timeline points
        const point = pointMap.get(seq);
        if (point) {
          if (visible) {
            point.classList.remove('hidden');
            point.style.display = 'block';
          } else {
            point.classList.add('hidden');
            point.style.display = 'none';
          }
        }
      }

      // Update chapter groups
      for (const [chapter, group] of chapterGroupMap.entries()) {
        const hasVisiblePoints = visibleChapters.has(chapter) && visibleChapters.get(chapter) > 0;
        if (hasVisiblePoints) {
          group.classList.remove('hidden');
          group.style.display = 'block';
        } else {
          group.classList.add('hidden');
          group.style.display = 'none';
        }
      }

      // Update city areas
      updateCityData();
      createCityAreas();
      
      // Se c'era un spider graph aperto e la città filtrata è ancora visibile, riaprilo
      if (activeSpiderPlace && cityData.has(activeSpiderPlace) && cityData.get(activeSpiderPlace).visibleCount > 0) {
        setTimeout(() => {
          const cityInfo = cityData.get(activeSpiderPlace);
          showSpiderGraph(activeSpiderPlace, cityInfo);
        }, 100);
      }

      clearHighlights();
      updateTimelineStats();
      map.invalidateSize();
    }

    function renderTimeline(filterFn) {
      timelineGrid.innerHTML = '';
      chapterGroupMap.clear();
      
      for (const [chapter, points] of chapterMap.entries()) {
        if (!filterFn(chapter)) continue;
        
        const group = document.createElement('div');
        group.className = 'chapter-group';
        group.dataset.chapter = chapter;

        const label = document.createElement('div');
        label.className = 'chapter-label';
        label.dataset.chapter = chapter;
        label.textContent = chapter;

        const pointsContainer = document.createElement('div');
        pointsContainer.className = 'chapter-group-points';
        
        points.forEach(point => {
          pointsContainer.appendChild(point);
        });

        group.appendChild(label);
        group.appendChild(pointsContainer);
        timelineGrid.appendChild(group);
        
        chapterGroupMap.set(chapter, group);
      }
      
      updateTimelineStats();
    }

    function toggleTimeline(filterFn, key) {
      btnPromessi.classList.remove('active');
      btnColonna.classList.remove('active');

      if (currentTimeline === key) {
        timeline.classList.remove('active');
        timelineGrid.innerHTML = '';
        currentTimeline = null;
        chapterGroupMap.clear();
        clearHighlights();
        timelineStats.textContent = '';
      } else {
        timeline.classList.add('active');
        currentTimeline = key;
        
        if (key === 'promessi') btnPromessi.classList.add('active');
        if (key === 'colonna') btnColonna.classList.add('active');
        
        renderTimeline(filterFn);
        
        setTimeout(() => {
          applyFilters();
        }, 200);
      }

      updateControlPositions();
      map.invalidateSize();
    }

    // Funzione per mostrare errori
    function showError(message) {
      const errorDiv = document.createElement('div');
      errorDiv.className = 'error-message';
      errorDiv.innerHTML = `
        <h3>⚠️ Errore</h3>
        <p>${message}</p>
        <button onclick="this.parentElement.remove()" style="margin-top: 10px; padding: 5px 15px; background: white; color: red; border: none; border-radius: 5px; cursor: pointer;">Chiudi</button>
      `;
      document.body.appendChild(errorDiv);
      
      // Auto-remove after 10 seconds
      setTimeout(() => {
        if (errorDiv.parentElement) {
          errorDiv.remove();
        }
      }, 10000);
    }

    // Map events
    map.on('zoomend moveend', () => {
      createCityAreas();
      
      // Aggiorna posizione spider graph se attivo
      if (currentSpiderGraph && activeSpiderPlace && cityData.has(activeSpiderPlace)) {
        const cityInfo = cityData.get(activeSpiderPlace);
        const visibleItems = cityInfo.items.filter(item => {
          const point = pointMap.get(item.sequence);
          return point && !point.classList.contains('hidden') && point.style.display !== 'none';
        });
        
        if (visibleItems.length > 0) {
          closeSpiderGraph();
          setTimeout(() => {
            createIntegratedSpiderGraph(activeSpiderPlace, cityInfo, visibleItems);
          }, 100);
        }
      }
      
      // Aggiorna posizione card se presente
      if (currentItemCard && currentItemCard.linkedCenter) {
        const mapContainer = map.getContainer();
        const mapRect = mapContainer.getBoundingClientRect();
        
        // Usa la stessa logica di posizionamento migliorata
        const cardWidth = 320;
        const padding = 80;
        const availableWidth = window.innerWidth - cardWidth - padding * 2;
        const leftPosition = Math.max(padding, Math.min(availableWidth, mapRect.right - cardWidth - padding));
        
        currentItemCard.style.left = leftPosition + 'px';
        currentItemCard.style.top = Math.max(80, mapRect.top + 80) + 'px';
        
        if (currentItemCard.connectionLine) {
          const mapPoint = map.latLngToContainerPoint(currentItemCard.linkedCenter);
          currentItemCard.connectionLine.style.left = (mapRect.left + mapPoint.x) + 'px';
          currentItemCard.connectionLine.style.top = (mapRect.top + mapPoint.y) + 'px';
        }
      }
    });

    map.on('click', (e) => {
      // Chiudi spider graph se si clicca sulla mappa vuota
      if (!e.originalEvent.target.closest('.city-area') && 
          !e.originalEvent.target.closest('.spider-element')) {
        closeSpiderGraph();
      }
    });

    // Event Listeners
    fabToggle.addEventListener('click', toggleFAB);
    fabTimeline.addEventListener('click', showTimelinePanel);
    fabFilters.addEventListener('click', showFiltersPanel);

    // Close panels when clicking outside
    document.addEventListener('click', (e) => {
      if (!fabContainer.contains(e.target)) {
        if (fabOpen) {
          timelinePanel.classList.remove('visible');
          filtersPanel.classList.remove('visible');
          fabTimeline.classList.remove('active');
          fabFilters.classList.remove('active');
        }
      }
    });

    // Caricamento dati demo se il file GeoJSON non esiste
    function loadDemoData() {
      console.log('Caricamento dati demo...');
      
      // Dati demo per testare l'applicazione
      const demoData = {
        "type": "FeatureCollection",
        "features": [
          {
            "type": "Feature",
            "properties": {
              "sequence": "1",
              "title": "Demo: Lecco e il suo territorio",
              "chapter": "Cap. I",
              "page_number": "5",
              "place": "Lecco",
              "authors": ["A. Manzoni"],
              "image": "",
              "link": "#"
            },
            "geometry": {
              "type": "Point",
              "coordinates": [9.3933, 45.8566]
            }
          },
          {
            "type": "Feature",
            "properties": {
              "sequence": "2",
              "title": "Demo: La casa di Lucia",
              "chapter": "Cap. II",
              "page_number": "12",
              "place": "Lecco",
              "authors": ["A. Manzoni"],
              "image": "",
              "link": "#"
            },
            "geometry": {
              "type": "Point",
              "coordinates": [9.3933, 45.8566]
            }
          },
          {
            "type": "Feature",
            "properties": {
              "sequence": "3",
              "title": "Demo: Milano - L'Innominato",
              "chapter": "Cap. XX",
              "page_number": "267",
              "place": "Milano",
              "authors": ["A. Manzoni"],
              "image": "",
              "link": "#"
            },
            "geometry": {
              "type": "Point",
              "coordinates": [9.1900, 45.4642]
            }
          },
          {
            "type": "Feature",
            "properties": {
              "sequence": "4",
              "title": "Demo: Bergamo",
              "chapter": "Cap. XV",
              "page_number": "189",
              "place": "Bergamo",
              "authors": ["A. Manzoni"],
              "image": "",
              "link": "#"
            },
            "geometry": {
              "type": "Point",
              "coordinates": [9.6696, 45.6983]
            }
          },
          {
            "type": "Feature",
            "properties": {
              "sequence": "5",
              "title": "Demo: La Colonna Infame",
              "chapter": "CI_Cap. I",
              "page_number": "1",
              "place": "Milano",
              "authors": ["A. Manzoni"],
              "image": "",
              "link": "#"
            },
            "geometry": {
              "type": "Point",
              "coordinates": [9.1900, 45.4642]
            }
          }
        ]
      };
      
      processGeoJSONData(demoData);
    }

    // Funzione per processare i dati GeoJSON
    function processGeoJSONData(data) {
      console.log('Processing GeoJSON data:', data);
      
      if (!data.features || data.features.length === 0) {
        throw new Error('No features found in GeoJSON');
      }
      
      sortedFeatures = data.features.sort(
        (a, b) => Number(a.properties.sequence) - Number(b.properties.sequence)
      );

      const chapterSet = new Set();
      const placeSet = new Set();
      const authorSet = new Set();

      // Process features and build city data
      sortedFeatures.forEach((feature, i) => {
        const props = feature.properties;
        const baseCoords = feature.geometry.coordinates.slice().reverse();
        const sequence = String(props.sequence);
        const chapter = props.chapter || "Capitolo sconosciuto";
        const place = props.place || "Luogo sconosciuto";
        const authors = props.authors || [];

        chapterSet.add(chapter);
        placeSet.add(place);
        authors.forEach(author => authorSet.add(author));

        // Store feature
        featureMap.set(sequence, feature);

        // Build city data - usa le coordinate della prima occorrenza
        if (!cityData.has(place)) {
          cityData.set(place, {
            coords: baseCoords,
            items: [],
            visibleCount: 0
          });
        }
        
        const cityInfo = cityData.get(place);
        const item = {
          sequence: sequence,
          title: props.title || "Senza titolo",
          chapter: chapter,
          page: props.page_number || "?",
          place: place,
          authors: authors,
          image: props.image || "",
          link: props.link || "#"
        };
        
        cityInfo.items.push(item);

        // Create timeline point
        const color = getColorForPlace(place);
        const point = document.createElement('div');
        point.className = 'timeline-point';
        point.title = `${props.title} (pag. ${props.page_number})`;
        point.dataset.sequence = sequence;
        point.dataset.chapter = chapter;
        point.dataset.place = place;
        point.style.backgroundColor = color;

        // Timeline point event listeners
        point.addEventListener('click', (e) => {
          e.stopPropagation();
          clearHighlights();
          
          // Chiudi eventuali spider graph aperti
          closeSpiderGraph();
          
          // Chiudi automaticamente la timeline per rendere visibile la card
          if (timeline.classList.contains('active')) {
            timeline.classList.remove('active');
            updateControlPositions();
            map.invalidateSize();
          }
          
          // Focus sulla città nella mappa con zoom appropriato
          const cityInfo = cityData.get(place);
          if (cityInfo) {
            const center = L.latLng(cityInfo.coords);
            map.setView(center, 13);
          }
          
          // Apri direttamente la card dell'item specifico dopo il focus
          setTimeout(() => {
            showItemCardDirect(item);
          }, 300);
          
          point.classList.add('active');
          setTimeout(() => point.classList.remove('active'), 2000);
        });

        // Highlight hover events
        let hoverTimeout;
        point.addEventListener('mouseenter', () => {
          hoverTimeout = setTimeout(() => {
            highlightPlacePoints(place, point);
          }, 300);
        });
        
        point.addEventListener('mouseleave', () => {
          clearTimeout(hoverTimeout);
          setTimeout(() => {
            if (currentHoveredPlace === place && !point.matches(':hover')) {
              clearHighlights();
            }
          }, 200);
        });

        // Add to maps
        if (!chapterMap.has(chapter)) {
          chapterMap.set(chapter, []);
        }
        chapterMap.get(chapter).push(point);
        pointMap.set(sequence, point);

        // Add to place points map
        if (!placePointsMap.has(place)) {
          placePointsMap.set(place, []);
        }
        placePointsMap.get(place).push(point);
      });

      // Calcola i conteggi iniziali
      updateCityData();

      // Create initial city areas
      createCityAreas();

      // Popola dropdown
      Array.from(chapterSet).sort().forEach(ch => {
        const opt = document.createElement('option');
        opt.value = ch;
        opt.textContent = ch;
        dropdownChapter.appendChild(opt);
      });

      Array.from(placeSet).sort().forEach(pl => {
        const opt = document.createElement('option');
        opt.value = pl;
        opt.textContent = pl;
        dropdownPlace.appendChild(opt);
      });

      Array.from(authorSet).sort().forEach(a => {
        const opt = document.createElement('option');
        opt.value = a;
        opt.textContent = a;
        dropdownAuthor.appendChild(opt);
      });

      console.log('Mappa geosemiotica caricata con successo:', {
        features: sortedFeatures.length,
        chapters: chapterSet.size,
        places: placeSet.size,
        authors: authorSet.size,
        cities: cityData.size
      });
    }

    // Caricamento dati GeoJSON con gestione errori migliorata
    fetch('dl_quarantana.geojson')
      .then(response => {
        console.log('Fetch response status:', response.status);
        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }
        return response.json();
      })
      .then(data => {
        processGeoJSONData(data);
      })
      .catch(error => {
        console.error('Errore nel caricamento del file GeoJSON:', error);
        showError('Impossibile caricare il file GeoJSON. Utilizzo dati demo per testare l\'applicazione.');
        loadDemoData();
      });

    // Timeline button events - aggiunto dopo che gli elementi sono stati inizializzati
    setTimeout(() => {
      if (btnPromessi && btnColonna) {
        btnPromessi.addEventListener('click', () => {
          toggleTimeline(chapter => !chapter.startsWith('CI_'), 'promessi');
        });

        btnColonna.addEventListener('click', () => {
          toggleTimeline(chapter => chapter.startsWith('CI_'), 'colonna');
        });
      }

      // Dropdown events
      [dropdownChapter, dropdownPlace, dropdownAuthor].forEach(dropdown => {
        if (dropdown) {
          dropdown.addEventListener('change', applyFilters);
        }
      });

      // Clear highlights when clicking outside timeline
      document.addEventListener('click', (e) => {
        if (!timeline.contains(e.target) && !e.target.closest('.spider-popup')) {
          clearHighlights();
        }
      });
    }, 1000);
  </script>
</body>
</html>